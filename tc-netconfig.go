package main

/*
   This program uses IPv6 autoconf prefix info, and optionally IPMI LAN address
   to identify an unconfigured server and configure networking. A lookup is
   performed against the Traffic Ops API, and if the IPv6 prefix is unique among
   all server objects in TO, then this is positively ID's the machine.

   As a backup method (in the case where prefixes may be shared between multiple
   servers), we can optionally attempt to obtain the BMC LAN IP via IPMI, and
   use this to lookup the host in TO.

   Optionally, this program will also set the system hostname using the value
   discovered from Traffic Ops.
*/

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"net"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"
	"time"

	tc "github.com/apache/trafficcontrol/lib/go-tc"
	toclient "github.com/apache/trafficcontrol/traffic_ops/client"
)

type Config struct {
	URL    string   `json:"to_url"`
	User   string   `json:"user"`
	Passwd string   `json:"passwd"`
	Nets   []string `json:"networks"`
	NS     []string `json:"nameservers"`
}

var config Config
var myHostName string

func LoadConfig(file string) (Config, error) {
	configFile, err := os.Open(file)
	if err != nil {
		return config, err
	}
	defer configFile.Close()
	jsonParser := json.NewDecoder(configFile)
	err = jsonParser.Decode(&config)
	return config, err
}

func getPrefix(netList []string) (*net.IPNet, error) {
	var myPrefix *net.IPNet
	ifaces, err := net.Interfaces()
	if err != nil {
		return nil, fmt.Errorf("getPrefix(): %+v\n", err.Error())
	} else {
		for _, i := range ifaces {
			addrs, err := i.Addrs()
			if err != nil {
				continue
			}
			for n := 0; n < len(netList); n += 1 {
				_, ipnet, _ := net.ParseCIDR(netList[n])
				for _, a := range addrs {
					myAddr := strings.Split(a.String(), "/")
					if ipnet.Contains(net.ParseIP(myAddr[0])) {
						_, prefix, _ := net.ParseCIDR(a.String())
						myPrefix = prefix
					}
				}
			}
		}
	}
	if myPrefix == nil {
		return myPrefix, fmt.Errorf("getPrefix(): unable to find interface that matches configured prefix(es): %+v", netList)
	}
	return myPrefix, nil
}

func getSideBandIP(output string) string {
	var parts []string
	outlines := strings.Split(output, "\n")
	l := len(outlines)
	for _, line := range outlines[1 : l-1] {
		ret, _ := regexp.MatchString("^IP\\sAddress\\s+:", line)
		if ret {
			parts = strings.Split(line, " : ")
		}
	}
	return parts[1]
}

func PrintOut(Fhandle *os.File, details tc.Server) {
	fmt.Fprintf(Fhandle, "# Generated by %s\n", os.Args[0])
	fmt.Fprintf(Fhandle, "# %s\n", time.Now().Format(time.RFC3339))
	fmt.Fprintf(Fhandle, "DEVICE=%s\n", details.InterfaceName)
	if strings.HasPrefix(details.InterfaceName, "bond") {
		fmt.Fprint(Fhandle, "TYPE=Bond\n")
		fmt.Fprint(Fhandle, "BONDING_OPTS=\"miimon=100 mode=4 lacp_rate=fast xmit_hash_policy=layer3+4\"\n")
	}
	fmt.Fprintf(Fhandle, "IPADDR=%s\n", details.IPAddress)
	fmt.Fprintf(Fhandle, "NETMASK=%s\n", details.IPNetmask)
	fmt.Fprintf(Fhandle, "GATEWAY=%s\n", details.IPGateway)
	fmt.Fprint(Fhandle, "IPV6INIT=yes\n")
	fmt.Fprintf(Fhandle, "IPV6_DEFAULTGW=%s\n", details.IP6Gateway)
	fmt.Fprintf(Fhandle, "IPV6ADDR=%s\n", details.IP6Address)
	fmt.Fprintf(Fhandle, "MTU=%d\n", details.InterfaceMtu)
	for idx, ns := range config.NS {
		if idx > 2 {
			// resolvers generally accept a limit of 3 nameservers
			break
		}
		fmt.Fprintf(Fhandle, "DNS%d=%s\n", idx+1, ns)
	}
	fmt.Fprint(Fhandle, "NETBOOT=no\n")
	fmt.Fprint(Fhandle, "BOOTPROTO=none\n")
	fmt.Fprint(Fhandle, "ONBOOT=yes\n")
}

func fix_hostname() {
	// updates the default HOSTNAME in sysconfig/network

	input, err := ioutil.ReadFile("/etc/sysconfig/network")
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}

	output := bytes.Replace(input, []byte("HOSTNAME=localhost"), []byte("HOSTNAME="+myHostName), -1)

	if err = ioutil.WriteFile("/etc/sysconfig/network", output, 0666); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}

func main() {
	var cpath_new string
	var count int
	var myDetails tc.Server
	var ipmiDetails tc.Server
	var foundIPMI int
	var myILOAddr string

	// define default config file path
	cpath, err := filepath.Abs(filepath.Dir(os.Args[0]))
	if err != nil {
		log.Fatal(err)
	}
	cpath_new = strings.Replace(cpath, "/bin", "/conf/config.json", 1)

	// command-line flags
	confPtr := flag.String("c", cpath_new, "Config file path")
	confIPMI := flag.Bool("i", false, "Use IPMI to fetch BMC LAN IP")
	confOut := flag.String("o", "undef", "Output file (optional)")
	confHostName := flag.Bool("s", false, "Set system hostname (optional, default=false)")
	flag.Parse()

	// load config json
	config, err := LoadConfig(*confPtr)
	if err != nil {
		fmt.Printf("Error parsing config file: %+v\n", err)
		os.Exit(1)
	}
	myPrefix, err := getPrefix(config.Nets)
	if err == nil {
		fmt.Printf("My global IPv6 prefix is %s\n", myPrefix)
	} else {
		fmt.Printf("Err: %+v\n", err)
		os.Exit(1)
	}

	// Get BMC LAN IP from IPMI
	if *confIPMI {
		out, err := exec.Command("ipmitool", "lan", "print").Output()
		if err != nil {
			fmt.Printf("Err: %+v\n", err)
			fmt.Println("Maybe try as root?")
			os.Exit(1)
		}
		myILOAddr = getSideBandIP(string(out))
	}

	// Traffic Ops connection params
	const AllowInsecureConnections = false
	const UserAgent = "tc-netconfig"
	const UseClientCache = false
	const TrafficOpsRequestTimeout = time.Second * time.Duration(10)
	// connect
	session, _, err := toclient.LoginWithAgent(
		config.URL,
		config.User,
		config.Passwd,
		AllowInsecureConnections,
		UserAgent,
		UseClientCache,
		TrafficOpsRequestTimeout)
	if err != nil {
		fmt.Printf("An error occurred while logging in:\n\t%v\n", err)
		os.Exit(1)
	}

	// Make TO API call for server details
	var host []tc.Server
	host, _, err = session.GetServers()
	if err != nil {
		fmt.Printf("An error occurred while getting host:\n\t%v\n", err)
		os.Exit(1)
	}

	for _, details := range host {
		myIp := strings.Split(details.IP6Address, "/")
		if myPrefix.Contains(net.ParseIP(myIp[0])) {
			myDetails = details
			count++
		}
		if *confIPMI {
			if details.ILOIPAddress == myILOAddr {
				ipmiDetails = details
				foundIPMI = 1
			}
		}
	}

	fmt.Printf("My IPv6 prefix found in TC  %d time(s)\n", count)

	Fhandle := os.Stdout
	if *confOut != "undef" {
		outfile, err := os.Create(*confOut)
		if err != nil {
			log.Fatal("Cannot create file", err)
		}
		defer outfile.Close()

		Fhandle = outfile
	}

	if count == 1 {
		fmt.Println("IPv6 prefix is unique in TC - using for self-ident")
		myHostName = myDetails.HostName + "." + myDetails.DomainName
		fmt.Printf("Discovered hostname: %s\n", myHostName)
		PrintOut(Fhandle, myDetails)
	} else if foundIPMI == 1 {
		fmt.Println("My BMC/ILO IP was found in TC - using for self-ident")
		fmt.Printf("Discovered hostname: %s\n", ipmiDetails.HostName)
		myHostName = ipmiDetails.HostName
		PrintOut(Fhandle, ipmiDetails)
	} else {
		fmt.Println("Unable to determine host info from Traffic Ops")
		os.Exit(1)
	}

	if *confHostName {
		fmt.Printf("Setting system hostname: %s\n", myHostName)
		fix_hostname()
		err := exec.Command("hostnamectl", "set-hostname", myHostName).Run()
		if err != nil {
			fmt.Printf("An error occurred while setting hostname:\n\t%v\n", err)
			os.Exit(1)
		}
	}
}
